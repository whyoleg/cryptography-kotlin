{"author":"whyoleg","body":"this could be removed in favor of `Custom Java providers` section above ","diff_hunk":"@@ -8,6 +8,11 @@ For supported targets and algorithms, please consult [Supported primitives secti\n \n * KeyFormat: doesn't support `JWK` key format yet\n \n+### EdDSA and XDH","id":2322958544,"in_reply_to_id":null,"line":11,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":11,"path":"docs/providers/jdk.md","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"this should be removed","diff_hunk":"@@ -21,6 +21,11 @@ For supported targets and algorithms, please consult [Supported primitives secti\n \n * KeyFormat: doesn't support `JWK` key format yet\n \n+### EdDSA and XDH","id":2322959257,"in_reply_to_id":null,"line":24,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":24,"path":"docs/providers/openssl3.md","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"it's not true: we could, and should support those, as we have both DER and PEM machinery implemented and used there.","diff_hunk":"@@ -8,6 +8,7 @@ For supported targets and algorithms, please consult [Supported primitives secti\n \n * KeyFormat: doesn't support `JWK` key format yet\n * AES.GCM supports only a default tag size of 96 bits\n+* EdDSA/XDH: Ed25519 and X25519 are supported via RAW key formats. DER/PEM for these curves are not exposed in CryptoKit and are not supported here.","id":2322963075,"in_reply_to_id":null,"line":11,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":11,"path":"docs/providers/cryptokit.md","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"it might be better, to mention instead, that those algorithms were added later (maybe add link to RFC?) and so might not be supported by all browsers","diff_hunk":"@@ -9,16 +9,27 @@ For supported targets and algorithms, please consult [Supported primitives secti\n * only `suspend` functions are supported, because `WebCrypto` API is async by default\n * AES.* (browser only): may not support `192 bit` keys\n * AES.CBC: only `padding=true` is supported\n+* EdDSA/XDH availability depends on the engine:","id":2322965396,"in_reply_to_id":null,"line":12,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":12,"path":"docs/providers/webcrypto.md","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"no need to have this, as we should not have this flag","diff_hunk":"@@ -9,16 +9,27 @@ For supported targets and algorithms, please consult [Supported primitives secti\n * only `suspend` functions are supported, because `WebCrypto` API is async by default\n * AES.* (browser only): may not support `192 bit` keys\n * AES.CBC: only `padding=true` is supported\n+* EdDSA/XDH availability depends on the engine:\n+  - Node.js, Firefox, Safari: supported (Ed25519/Ed448, X25519/X448)\n+  - Chromium-based (Chrome/Edge/Opera): requires enabling experimental web platform features; otherwise not exposed by the provider\n \n ## Example\n \n ```kotlin\n+// default provider\n val provider = CryptographyProvider.WebCrypto // or CryptographyProvider.Default\n \n // get some algorithm\n provider.get(SHA512)\n ```\n \n+To opt-in to EdDSA/XDH on Chromium-based engines (with experimental web platform features enabled),","id":2322966182,"in_reply_to_id":null,"line":26,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":26,"path":"docs/providers/webcrypto.md","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"I don't think, that it's correct to do it like this.\nIf Chromium will at some point enable this support, or some other environment - we will need to release a new version.\nInstead, it's fine to fail at runtime, that algorithm is not supported with an exception coming from WebCrypto.\nIt's the same to how JDK provider fails, if algorithm is not supported by the security provider\n\nLet's remove this machinery (including `detectEngine`)","diff_hunk":"@@ -15,6 +17,18 @@ public val CryptographyProvider.Companion.WebCrypto: CryptographyProvider by def\n internal object WebCryptoCryptographyProvider : CryptographyProvider() {\n     override val name: String get() = \"WebCrypto\"\n \n+    private val engine: Engine = detectEngine()","id":2322973682,"in_reply_to_id":null,"line":20,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":20,"path":"cryptography-providers/webcrypto/src/commonMain/kotlin/WebCryptoCryptographyProvider.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"can't we just pass `publicKey.algorithm` there?\nsame for `privateKey.algorithm` below","diff_hunk":"@@ -0,0 +1,107 @@\n+/*\n+ * Copyright (c) 2025 Oleg Yukhnevich. Use of this source code is governed by the Apache 2.0 license.\n+ */\n+\n+package dev.whyoleg.cryptography.providers.webcrypto.algorithms\n+\n+import dev.whyoleg.cryptography.algorithms.*\n+import dev.whyoleg.cryptography.materials.key.*\n+import dev.whyoleg.cryptography.operations.*\n+import dev.whyoleg.cryptography.providers.webcrypto.internal.*\n+import dev.whyoleg.cryptography.providers.webcrypto.materials.*\n+import dev.whyoleg.cryptography.providers.webcrypto.operations.*\n+import dev.whyoleg.cryptography.providers.base.materials.*\n+import dev.whyoleg.cryptography.serialization.pem.*\n+\n+internal object WebCryptoEdDSA : EdDSA {\n+    private fun curveName(curve: EdDSA.Curve): String = when (curve) {\n+        EdDSA.Curve.Ed25519 -\u003e \"Ed25519\"\n+        EdDSA.Curve.Ed448   -\u003e \"Ed448\"\n+    }\n+\n+    override fun publicKeyDecoder(curve: EdDSA.Curve): KeyDecoder\u003cEdDSA.PublicKey.Format, EdDSA.PublicKey\u003e = WebCryptoKeyDecoder(\n+        algorithm = Algorithm(curveName(curve)),\n+        keyProcessor = EdPublicKeyProcessor,\n+        keyWrapper = WebCryptoKeyWrapper(arrayOf(\"verify\")) { EdDsaPublicKey(it) },\n+    )\n+\n+    override fun privateKeyDecoder(curve: EdDSA.Curve): KeyDecoder\u003cEdDSA.PrivateKey.Format, EdDSA.PrivateKey\u003e = WebCryptoKeyDecoder(\n+        algorithm = Algorithm(curveName(curve)),\n+        keyProcessor = EdPrivateKeyProcessor,\n+        keyWrapper = WebCryptoKeyWrapper(arrayOf(\"sign\")) { EdDsaPrivateKey(it) },\n+    )\n+\n+    override fun keyPairGenerator(curve: EdDSA.Curve): KeyGenerator\u003cEdDSA.KeyPair\u003e = WebCryptoAsymmetricKeyGenerator(\n+        algorithm = Algorithm(curveName(curve)),\n+        keyUsages = arrayOf(\"verify\", \"sign\"),\n+        keyPairWrapper = { EdDsaKeyPair(EdDsaPublicKey(it.publicKey), EdDsaPrivateKey(it.privateKey)) },\n+    )\n+\n+    private class EdDsaKeyPair(\n+        override val publicKey: EdDSA.PublicKey,\n+        override val privateKey: EdDSA.PrivateKey,\n+    ) : EdDSA.KeyPair\n+\n+    private class EdDsaPublicKey(\n+        val publicKey: CryptoKey,\n+    ) : WebCryptoEncodableKey\u003cEdDSA.PublicKey.Format\u003e(publicKey, EdPublicKeyProcessor), EdDSA.PublicKey {\n+        override fun signatureVerifier(): SignatureVerifier {\n+            return WebCryptoSignatureVerifier(Algorithm(publicKey.algorithm.algorithmName), publicKey)","id":2322986311,"in_reply_to_id":null,"line":49,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":49,"path":"cryptography-providers/webcrypto/src/commonMain/kotlin/algorithms/WebCryptoEdDSA.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"Something is wrong here: we should have both `jwk` and `raw` here too. Also it should be tested","diff_hunk":"@@ -0,0 +1,107 @@\n+/*\n+ * Copyright (c) 2025 Oleg Yukhnevich. Use of this source code is governed by the Apache 2.0 license.\n+ */\n+\n+package dev.whyoleg.cryptography.providers.webcrypto.algorithms\n+\n+import dev.whyoleg.cryptography.algorithms.*\n+import dev.whyoleg.cryptography.materials.key.*\n+import dev.whyoleg.cryptography.operations.*\n+import dev.whyoleg.cryptography.providers.webcrypto.internal.*\n+import dev.whyoleg.cryptography.providers.webcrypto.materials.*\n+import dev.whyoleg.cryptography.providers.webcrypto.operations.*\n+import dev.whyoleg.cryptography.providers.base.materials.*\n+import dev.whyoleg.cryptography.serialization.pem.*\n+\n+internal object WebCryptoEdDSA : EdDSA {\n+    private fun curveName(curve: EdDSA.Curve): String = when (curve) {\n+        EdDSA.Curve.Ed25519 -\u003e \"Ed25519\"\n+        EdDSA.Curve.Ed448   -\u003e \"Ed448\"\n+    }\n+\n+    override fun publicKeyDecoder(curve: EdDSA.Curve): KeyDecoder\u003cEdDSA.PublicKey.Format, EdDSA.PublicKey\u003e = WebCryptoKeyDecoder(\n+        algorithm = Algorithm(curveName(curve)),\n+        keyProcessor = EdPublicKeyProcessor,\n+        keyWrapper = WebCryptoKeyWrapper(arrayOf(\"verify\")) { EdDsaPublicKey(it) },\n+    )\n+\n+    override fun privateKeyDecoder(curve: EdDSA.Curve): KeyDecoder\u003cEdDSA.PrivateKey.Format, EdDSA.PrivateKey\u003e = WebCryptoKeyDecoder(\n+        algorithm = Algorithm(curveName(curve)),\n+        keyProcessor = EdPrivateKeyProcessor,\n+        keyWrapper = WebCryptoKeyWrapper(arrayOf(\"sign\")) { EdDsaPrivateKey(it) },\n+    )\n+\n+    override fun keyPairGenerator(curve: EdDSA.Curve): KeyGenerator\u003cEdDSA.KeyPair\u003e = WebCryptoAsymmetricKeyGenerator(\n+        algorithm = Algorithm(curveName(curve)),\n+        keyUsages = arrayOf(\"verify\", \"sign\"),\n+        keyPairWrapper = { EdDsaKeyPair(EdDsaPublicKey(it.publicKey), EdDsaPrivateKey(it.privateKey)) },\n+    )\n+\n+    private class EdDsaKeyPair(\n+        override val publicKey: EdDSA.PublicKey,\n+        override val privateKey: EdDSA.PrivateKey,\n+    ) : EdDSA.KeyPair\n+\n+    private class EdDsaPublicKey(\n+        val publicKey: CryptoKey,\n+    ) : WebCryptoEncodableKey\u003cEdDSA.PublicKey.Format\u003e(publicKey, EdPublicKeyProcessor), EdDSA.PublicKey {\n+        override fun signatureVerifier(): SignatureVerifier {\n+            return WebCryptoSignatureVerifier(Algorithm(publicKey.algorithm.algorithmName), publicKey)\n+        }\n+    }\n+\n+    private class EdDsaPrivateKey(\n+        val privateKey: CryptoKey,\n+    ) : WebCryptoEncodableKey\u003cEdDSA.PrivateKey.Format\u003e(privateKey, EdPrivateKeyProcessor), EdDSA.PrivateKey {\n+        override fun signatureGenerator(): SignatureGenerator {\n+            return WebCryptoSignatureGenerator(Algorithm(privateKey.algorithm.algorithmName), privateKey)\n+        }\n+    }\n+}\n+\n+private object EdPublicKeyProcessor : WebCryptoKeyProcessor\u003cEdDSA.PublicKey.Format\u003e() {\n+    override fun stringFormat(format: EdDSA.PublicKey.Format): String = when (format) {\n+        EdDSA.PublicKey.Format.JWK -\u003e \"jwk\"\n+        EdDSA.PublicKey.Format.RAW -\u003e \"raw\"\n+        EdDSA.PublicKey.Format.DER,\n+        EdDSA.PublicKey.Format.PEM -\u003e \"spki\"\n+    }\n+\n+    override fun beforeDecoding(algorithm: Algorithm, format: EdDSA.PublicKey.Format, key: ByteArray): ByteArray = when (format) {\n+        EdDSA.PublicKey.Format.JWK -\u003e key\n+        EdDSA.PublicKey.Format.RAW -\u003e key\n+        EdDSA.PublicKey.Format.DER -\u003e key\n+        EdDSA.PublicKey.Format.PEM -\u003e unwrapPem(PemLabel.PublicKey, key)\n+    }\n+\n+    override fun afterEncoding(format: EdDSA.PublicKey.Format, key: ByteArray): ByteArray = when (format) {\n+        EdDSA.PublicKey.Format.JWK -\u003e key\n+        EdDSA.PublicKey.Format.RAW -\u003e key\n+        EdDSA.PublicKey.Format.DER -\u003e key\n+        EdDSA.PublicKey.Format.PEM -\u003e wrapPem(PemLabel.PublicKey, key)\n+    }\n+}\n+\n+private object EdPrivateKeyProcessor : WebCryptoKeyProcessor\u003cEdDSA.PrivateKey.Format\u003e() {\n+    override fun stringFormat(format: EdDSA.PrivateKey.Format): String = when (format) {\n+        EdDSA.PrivateKey.Format.JWK,","id":2322988363,"in_reply_to_id":null,"line":87,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":87,"path":"cryptography-providers/webcrypto/src/commonMain/kotlin/algorithms/WebCryptoEdDSA.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"all the same comments from `WebCryptoEdDSA` are applied here","diff_hunk":"@@ -0,0 +1,136 @@\n+/*\n+ * Copyright (c) 2025 Oleg Yukhnevich. Use of this source code is governed by the Apache 2.0 license.\n+ */\n+\n+package dev.whyoleg.cryptography.providers.webcrypto.algorithms\n+\n+import dev.whyoleg.cryptography.algorithms.*\n+import dev.whyoleg.cryptography.materials.key.*\n+import dev.whyoleg.cryptography.operations.*\n+import dev.whyoleg.cryptography.providers.webcrypto.internal.*\n+import dev.whyoleg.cryptography.providers.webcrypto.materials.*\n+import dev.whyoleg.cryptography.providers.base.materials.*\n+import dev.whyoleg.cryptography.serialization.pem.*\n+\n+internal object WebCryptoXDH : XDH {","id":2322993298,"in_reply_to_id":null,"line":15,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":15,"path":"cryptography-providers/webcrypto/src/commonMain/kotlin/algorithms/WebCryptoXDH.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"it looks like we can just remove `EcdhKeyDeriveAlgorithm` and use `KeyDeriveAlgorithm` everywhere?","diff_hunk":"@@ -31,6 +31,7 @@ internal expect val Algorithm.ecKeyAlgorithmNamedCurve: String\n internal expect fun EcdsaSignatureAlgorithm(hash: String): Algorithm\n \n internal expect fun EcdhKeyDeriveAlgorithm(publicKey: CryptoKey): Algorithm","id":2322999331,"in_reply_to_id":null,"line":33,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":33,"path":"cryptography-providers/webcrypto/src/commonMain/kotlin/internal/Algorithms.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"Those should be definitely dropped. If there is some problem with this on CI and locally, I could take a look. probably we can just pass experimental argument in karma somewhere.","diff_hunk":"@@ -141,6 +146,11 @@ fun ProviderTestScope.supports(algorithmId: CryptographyAlgorithmId\u003c*\u003e): Boolean\n     when (algorithmId) {\n         AES.CMAC if provider.isJdkDefault                      -\u003e \"Default JDK provider doesn't support AES-CMAC, only supported with BouncyCastle\"\n         RSA.PSS if provider.isJdkDefault \u0026\u0026 platform.isAndroid -\u003e \"JDK provider on Android doesn't support RSASSA-PSS\"\n+        EdDSA if provider.isWebCrypto                          -\u003e \"WebCrypto EdDSA not yet supported in this engine\"\n+        XDH  if provider.isWebCrypto                           -\u003e \"WebCrypto X25519/X448 not yet supported in this engine\"","id":2323007111,"in_reply_to_id":null,"line":150,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":150,"path":"cryptography-providers/tests/src/commonMain/kotlin/support.kt","side":"RIGHT","start_line":149}
{"author":"whyoleg","body":"I think that it should be the same, as for `XDH` - those are supported from JDK 11","diff_hunk":"@@ -141,6 +146,11 @@ fun ProviderTestScope.supports(algorithmId: CryptographyAlgorithmId\u003c*\u003e): Boolean\n     when (algorithmId) {\n         AES.CMAC if provider.isJdkDefault                      -\u003e \"Default JDK provider doesn't support AES-CMAC, only supported with BouncyCastle\"\n         RSA.PSS if provider.isJdkDefault \u0026\u0026 platform.isAndroid -\u003e \"JDK provider on Android doesn't support RSASSA-PSS\"\n+        EdDSA if provider.isWebCrypto                          -\u003e \"WebCrypto EdDSA not yet supported in this engine\"\n+        XDH  if provider.isWebCrypto                           -\u003e \"WebCrypto X25519/X448 not yet supported in this engine\"\n+        // Some JDKs used in CI (jvm / jvm11) lack these algorithms\n+        EdDSA if provider.isJdkDefault                         -\u003e \"Default JDK may not support EdDSA on this JDK version\"","id":2323016503,"in_reply_to_id":null,"line":152,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":152,"path":"cryptography-providers/tests/src/commonMain/kotlin/support.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"should be just `!context.provider.isApple` after the engine machinery is removed","diff_hunk":"@@ -51,6 +51,11 @@ abstract class SupportedAlgorithmsTest(provider: CryptographyProvider) : Provide\n         assertSupports(ECDSA)\n         assertSupports(ECDH, !context.provider.isApple)\n \n+        // Edwards-family\n+        // WebCrypto availability depends on engine; skip expecting it there\n+        assertSupports(EdDSA, !context.provider.isApple \u0026\u0026 !context.provider.isWebCrypto)","id":2323019510,"in_reply_to_id":null,"line":56,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":56,"path":"cryptography-providers/tests/src/commonMain/kotlin/default/SupportedAlgorithmsTest.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"We should also add compatibility tests for both EdDSA and XDH, similar to the ECDSA and ECDH","diff_hunk":"@@ -0,0 +1,49 @@\n+/*\n+ * Copyright (c) 2025 Oleg Yukhnevich. Use of this source code is governed by the Apache 2.0 license.\n+ */\n+\n+package dev.whyoleg.cryptography.providers.tests.default\n+\n+import dev.whyoleg.cryptography.*\n+import dev.whyoleg.cryptography.algorithms.*\n+import dev.whyoleg.cryptography.providers.tests.*\n+import dev.whyoleg.cryptography.random.*\n+import kotlinx.io.bytestring.*\n+import kotlin.test.*\n+\n+abstract class EdDsaTest(provider: CryptographyProvider) : AlgorithmTest\u003cEdDSA\u003e(EdDSA, provider), SignatureTest {","id":2323024591,"in_reply_to_id":null,"line":14,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":14,"path":"cryptography-providers/tests/src/commonMain/kotlin/default/EdDsaTest.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"we should support `RAW` format (openSSL should support it)","diff_hunk":"@@ -0,0 +1,114 @@\n+/*\n+ * Copyright (c) 2025 Oleg Yukhnevich. Use of this source code is governed by the Apache 2.0 license.\n+ */\n+\n+package dev.whyoleg.cryptography.providers.openssl3.algorithms\n+\n+import dev.whyoleg.cryptography.algorithms.*\n+import dev.whyoleg.cryptography.materials.key.*\n+import dev.whyoleg.cryptography.operations.*\n+import dev.whyoleg.cryptography.providers.base.*\n+import dev.whyoleg.cryptography.providers.openssl3.internal.*\n+import dev.whyoleg.cryptography.providers.openssl3.internal.cinterop.*\n+import dev.whyoleg.cryptography.providers.openssl3.materials.*\n+import kotlinx.cinterop.*\n+import platform.posix.*\n+import kotlin.experimental.*\n+\n+internal object Openssl3XDH : XDH {\n+    private fun algorithmName(curve: XDH.Curve): String = when (curve) {\n+        XDH.Curve.X25519 -\u003e \"X25519\"\n+        XDH.Curve.X448   -\u003e \"X448\"\n+    }\n+\n+    override fun publicKeyDecoder(curve: XDH.Curve): KeyDecoder\u003cXDH.PublicKey.Format, XDH.PublicKey\u003e =\n+        object : Openssl3PublicKeyDecoder\u003cXDH.PublicKey.Format, XDH.PublicKey\u003e(algorithmName(curve)) {\n+            override fun inputType(format: XDH.PublicKey.Format): String = when (format) {\n+                XDH.PublicKey.Format.DER -\u003e \"DER\"\n+                XDH.PublicKey.Format.PEM -\u003e \"PEM\"\n+                XDH.PublicKey.Format.JWK,\n+                XDH.PublicKey.Format.RAW -\u003e error(\"$format format is not supported\")","id":2323027291,"in_reply_to_id":null,"line":30,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":30,"path":"cryptography-providers/openssl3/api/src/commonMain/kotlin/algorithms/Openssl3XDH.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"we should support `RAW` format (openSSL should support it)","diff_hunk":"@@ -0,0 +1,114 @@\n+/*\n+ * Copyright (c) 2025 Oleg Yukhnevich. Use of this source code is governed by the Apache 2.0 license.\n+ */\n+\n+package dev.whyoleg.cryptography.providers.openssl3.algorithms\n+\n+import dev.whyoleg.cryptography.algorithms.*\n+import dev.whyoleg.cryptography.materials.key.*\n+import dev.whyoleg.cryptography.operations.*\n+import dev.whyoleg.cryptography.providers.base.*\n+import dev.whyoleg.cryptography.providers.openssl3.internal.*\n+import dev.whyoleg.cryptography.providers.openssl3.internal.cinterop.*\n+import dev.whyoleg.cryptography.providers.openssl3.materials.*\n+import kotlinx.cinterop.*\n+import platform.posix.*\n+import kotlin.experimental.*\n+\n+internal object Openssl3XDH : XDH {\n+    private fun algorithmName(curve: XDH.Curve): String = when (curve) {\n+        XDH.Curve.X25519 -\u003e \"X25519\"\n+        XDH.Curve.X448   -\u003e \"X448\"\n+    }\n+\n+    override fun publicKeyDecoder(curve: XDH.Curve): KeyDecoder\u003cXDH.PublicKey.Format, XDH.PublicKey\u003e =\n+        object : Openssl3PublicKeyDecoder\u003cXDH.PublicKey.Format, XDH.PublicKey\u003e(algorithmName(curve)) {\n+            override fun inputType(format: XDH.PublicKey.Format): String = when (format) {\n+                XDH.PublicKey.Format.DER -\u003e \"DER\"\n+                XDH.PublicKey.Format.PEM -\u003e \"PEM\"\n+                XDH.PublicKey.Format.JWK,\n+                XDH.PublicKey.Format.RAW -\u003e error(\"$format format is not supported\")\n+            }\n+\n+            override fun wrapKey(key: CPointer\u003cEVP_PKEY\u003e): XDH.PublicKey = XdhPublicKey(key)\n+        }\n+\n+    override fun privateKeyDecoder(curve: XDH.Curve): KeyDecoder\u003cXDH.PrivateKey.Format, XDH.PrivateKey\u003e =\n+        object : Openssl3PrivateKeyDecoder\u003cXDH.PrivateKey.Format, XDH.PrivateKey\u003e(algorithmName(curve)) {\n+            override fun inputType(format: XDH.PrivateKey.Format): String = when (format) {\n+                XDH.PrivateKey.Format.DER -\u003e \"DER\"\n+                XDH.PrivateKey.Format.PEM -\u003e \"PEM\"\n+                XDH.PrivateKey.Format.JWK,\n+                XDH.PrivateKey.Format.RAW -\u003e error(\"$format format is not supported\")","id":2323027616,"in_reply_to_id":null,"line":42,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":42,"path":"cryptography-providers/openssl3/api/src/commonMain/kotlin/algorithms/Openssl3XDH.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"let's extract the function from `ecdh` implementation to `operations` package and use it here, instead of just copying ","diff_hunk":"@@ -0,0 +1,114 @@\n+/*\n+ * Copyright (c) 2025 Oleg Yukhnevich. Use of this source code is governed by the Apache 2.0 license.\n+ */\n+\n+package dev.whyoleg.cryptography.providers.openssl3.algorithms\n+\n+import dev.whyoleg.cryptography.algorithms.*\n+import dev.whyoleg.cryptography.materials.key.*\n+import dev.whyoleg.cryptography.operations.*\n+import dev.whyoleg.cryptography.providers.base.*\n+import dev.whyoleg.cryptography.providers.openssl3.internal.*\n+import dev.whyoleg.cryptography.providers.openssl3.internal.cinterop.*\n+import dev.whyoleg.cryptography.providers.openssl3.materials.*\n+import kotlinx.cinterop.*\n+import platform.posix.*\n+import kotlin.experimental.*\n+\n+internal object Openssl3XDH : XDH {\n+    private fun algorithmName(curve: XDH.Curve): String = when (curve) {\n+        XDH.Curve.X25519 -\u003e \"X25519\"\n+        XDH.Curve.X448   -\u003e \"X448\"\n+    }\n+\n+    override fun publicKeyDecoder(curve: XDH.Curve): KeyDecoder\u003cXDH.PublicKey.Format, XDH.PublicKey\u003e =\n+        object : Openssl3PublicKeyDecoder\u003cXDH.PublicKey.Format, XDH.PublicKey\u003e(algorithmName(curve)) {\n+            override fun inputType(format: XDH.PublicKey.Format): String = when (format) {\n+                XDH.PublicKey.Format.DER -\u003e \"DER\"\n+                XDH.PublicKey.Format.PEM -\u003e \"PEM\"\n+                XDH.PublicKey.Format.JWK,\n+                XDH.PublicKey.Format.RAW -\u003e error(\"$format format is not supported\")\n+            }\n+\n+            override fun wrapKey(key: CPointer\u003cEVP_PKEY\u003e): XDH.PublicKey = XdhPublicKey(key)\n+        }\n+\n+    override fun privateKeyDecoder(curve: XDH.Curve): KeyDecoder\u003cXDH.PrivateKey.Format, XDH.PrivateKey\u003e =\n+        object : Openssl3PrivateKeyDecoder\u003cXDH.PrivateKey.Format, XDH.PrivateKey\u003e(algorithmName(curve)) {\n+            override fun inputType(format: XDH.PrivateKey.Format): String = when (format) {\n+                XDH.PrivateKey.Format.DER -\u003e \"DER\"\n+                XDH.PrivateKey.Format.PEM -\u003e \"PEM\"\n+                XDH.PrivateKey.Format.JWK,\n+                XDH.PrivateKey.Format.RAW -\u003e error(\"$format format is not supported\")\n+            }\n+\n+            override fun wrapKey(key: CPointer\u003cEVP_PKEY\u003e): XDH.PrivateKey = XdhPrivateKey(key)\n+        }\n+\n+    override fun keyPairGenerator(curve: XDH.Curve): KeyGenerator\u003cXDH.KeyPair\u003e =\n+        object : Openssl3KeyPairGenerator\u003cXDH.KeyPair\u003e(algorithmName(curve)) {\n+            override fun MemScope.createParams(): CValuesRef\u003cOSSL_PARAM\u003e? = null\n+            override fun wrapKeyPair(keyPair: CPointer\u003cEVP_PKEY\u003e): XDH.KeyPair = XdhKeyPair(\n+                publicKey = XdhPublicKey(keyPair),\n+                privateKey = XdhPrivateKey(keyPair)\n+            )\n+        }\n+\n+    private class XdhKeyPair(\n+        override val publicKey: XDH.PublicKey,\n+        override val privateKey: XDH.PrivateKey,\n+    ) : XDH.KeyPair\n+\n+    private class XdhPublicKey(\n+        key: CPointer\u003cEVP_PKEY\u003e,\n+    ) : XDH.PublicKey, Openssl3PublicKeyEncodable\u003cXDH.PublicKey.Format\u003e(key), SharedSecretGenerator\u003cXDH.PrivateKey\u003e {\n+        override fun outputType(format: XDH.PublicKey.Format): String = when (format) {\n+            XDH.PublicKey.Format.DER -\u003e \"DER\"\n+            XDH.PublicKey.Format.PEM -\u003e \"PEM\"\n+            XDH.PublicKey.Format.JWK,\n+            XDH.PublicKey.Format.RAW -\u003e error(\"$format format is not supported\")\n+        }\n+\n+        override fun sharedSecretGenerator(): SharedSecretGenerator\u003cXDH.PrivateKey\u003e = this\n+        override fun generateSharedSecretToByteArrayBlocking(other: XDH.PrivateKey): ByteArray {\n+            check(other is XdhPrivateKey)\n+            return deriveSharedSecret(publicKey = key, privateKey = other.key)\n+        }\n+    }\n+\n+    private class XdhPrivateKey(\n+        key: CPointer\u003cEVP_PKEY\u003e,\n+    ) : XDH.PrivateKey, Openssl3PrivateKeyEncodable\u003cXDH.PrivateKey.Format\u003e(key), SharedSecretGenerator\u003cXDH.PublicKey\u003e {\n+        override fun outputType(format: XDH.PrivateKey.Format): String = when (format) {\n+            XDH.PrivateKey.Format.DER -\u003e \"DER\"\n+            XDH.PrivateKey.Format.PEM -\u003e \"PEM\"\n+            XDH.PrivateKey.Format.JWK,\n+            XDH.PrivateKey.Format.RAW -\u003e error(\"$format format is not supported\")\n+        }\n+\n+        override fun sharedSecretGenerator(): SharedSecretGenerator\u003cXDH.PublicKey\u003e = this\n+        override fun generateSharedSecretToByteArrayBlocking(other: XDH.PublicKey): ByteArray {\n+            check(other is XdhPublicKey)\n+            return deriveSharedSecret(publicKey = other.key, privateKey = key)\n+        }\n+    }\n+}\n+\n+@OptIn(UnsafeNumber::class)\n+private fun deriveSharedSecret(","id":2323033174,"in_reply_to_id":null,"line":98,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":98,"path":"cryptography-providers/openssl3/api/src/commonMain/kotlin/algorithms/Openssl3XDH.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"we should support RAW format (openSSL should support it)\nsame in other places","diff_hunk":"@@ -0,0 +1,265 @@\n+/*\n+ * Copyright (c) 2025 Oleg Yukhnevich. Use of this source code is governed by the Apache 2.0 license.\n+ */\n+\n+package dev.whyoleg.cryptography.providers.openssl3.algorithms\n+\n+import dev.whyoleg.cryptography.algorithms.*\n+import dev.whyoleg.cryptography.materials.key.*\n+import dev.whyoleg.cryptography.operations.*\n+import dev.whyoleg.cryptography.providers.base.*\n+import dev.whyoleg.cryptography.providers.openssl3.internal.*\n+import dev.whyoleg.cryptography.providers.openssl3.internal.cinterop.*\n+import dev.whyoleg.cryptography.providers.openssl3.materials.*\n+import kotlinx.cinterop.*\n+import platform.posix.*\n+import kotlin.experimental.*\n+\n+internal object Openssl3EdDSA : EdDSA {\n+    private fun algorithmName(curve: EdDSA.Curve): String = when (curve) {\n+        EdDSA.Curve.Ed25519 -\u003e \"ED25519\"\n+        EdDSA.Curve.Ed448   -\u003e \"ED448\"\n+    }\n+\n+    override fun publicKeyDecoder(curve: EdDSA.Curve): KeyDecoder\u003cEdDSA.PublicKey.Format, EdDSA.PublicKey\u003e =\n+        object : Openssl3PublicKeyDecoder\u003cEdDSA.PublicKey.Format, EdDSA.PublicKey\u003e(algorithmName(curve)) {\n+            override fun inputType(format: EdDSA.PublicKey.Format): String = when (format) {\n+                EdDSA.PublicKey.Format.DER -\u003e \"DER\"\n+                EdDSA.PublicKey.Format.PEM -\u003e \"PEM\"\n+                EdDSA.PublicKey.Format.JWK,\n+                EdDSA.PublicKey.Format.RAW -\u003e error(\"$format format is not supported\")","id":2323039843,"in_reply_to_id":null,"line":30,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":30,"path":"cryptography-providers/openssl3/api/src/commonMain/kotlin/algorithms/Openssl3EdDSA.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"we should support RAW format (openSSL should support it)","diff_hunk":"@@ -0,0 +1,114 @@\n+/*\n+ * Copyright (c) 2025 Oleg Yukhnevich. Use of this source code is governed by the Apache 2.0 license.\n+ */\n+\n+package dev.whyoleg.cryptography.providers.openssl3.algorithms\n+\n+import dev.whyoleg.cryptography.algorithms.*\n+import dev.whyoleg.cryptography.materials.key.*\n+import dev.whyoleg.cryptography.operations.*\n+import dev.whyoleg.cryptography.providers.base.*\n+import dev.whyoleg.cryptography.providers.openssl3.internal.*\n+import dev.whyoleg.cryptography.providers.openssl3.internal.cinterop.*\n+import dev.whyoleg.cryptography.providers.openssl3.materials.*\n+import kotlinx.cinterop.*\n+import platform.posix.*\n+import kotlin.experimental.*\n+\n+internal object Openssl3XDH : XDH {\n+    private fun algorithmName(curve: XDH.Curve): String = when (curve) {\n+        XDH.Curve.X25519 -\u003e \"X25519\"\n+        XDH.Curve.X448   -\u003e \"X448\"\n+    }\n+\n+    override fun publicKeyDecoder(curve: XDH.Curve): KeyDecoder\u003cXDH.PublicKey.Format, XDH.PublicKey\u003e =\n+        object : Openssl3PublicKeyDecoder\u003cXDH.PublicKey.Format, XDH.PublicKey\u003e(algorithmName(curve)) {\n+            override fun inputType(format: XDH.PublicKey.Format): String = when (format) {\n+                XDH.PublicKey.Format.DER -\u003e \"DER\"\n+                XDH.PublicKey.Format.PEM -\u003e \"PEM\"\n+                XDH.PublicKey.Format.JWK,\n+                XDH.PublicKey.Format.RAW -\u003e error(\"$format format is not supported\")\n+            }\n+\n+            override fun wrapKey(key: CPointer\u003cEVP_PKEY\u003e): XDH.PublicKey = XdhPublicKey(key)\n+        }\n+\n+    override fun privateKeyDecoder(curve: XDH.Curve): KeyDecoder\u003cXDH.PrivateKey.Format, XDH.PrivateKey\u003e =\n+        object : Openssl3PrivateKeyDecoder\u003cXDH.PrivateKey.Format, XDH.PrivateKey\u003e(algorithmName(curve)) {\n+            override fun inputType(format: XDH.PrivateKey.Format): String = when (format) {\n+                XDH.PrivateKey.Format.DER -\u003e \"DER\"\n+                XDH.PrivateKey.Format.PEM -\u003e \"PEM\"\n+                XDH.PrivateKey.Format.JWK,\n+                XDH.PrivateKey.Format.RAW -\u003e error(\"$format format is not supported\")\n+            }\n+\n+            override fun wrapKey(key: CPointer\u003cEVP_PKEY\u003e): XDH.PrivateKey = XdhPrivateKey(key)\n+        }\n+\n+    override fun keyPairGenerator(curve: XDH.Curve): KeyGenerator\u003cXDH.KeyPair\u003e =\n+        object : Openssl3KeyPairGenerator\u003cXDH.KeyPair\u003e(algorithmName(curve)) {\n+            override fun MemScope.createParams(): CValuesRef\u003cOSSL_PARAM\u003e? = null\n+            override fun wrapKeyPair(keyPair: CPointer\u003cEVP_PKEY\u003e): XDH.KeyPair = XdhKeyPair(\n+                publicKey = XdhPublicKey(keyPair),\n+                privateKey = XdhPrivateKey(keyPair)\n+            )\n+        }\n+\n+    private class XdhKeyPair(\n+        override val publicKey: XDH.PublicKey,\n+        override val privateKey: XDH.PrivateKey,\n+    ) : XDH.KeyPair\n+\n+    private class XdhPublicKey(\n+        key: CPointer\u003cEVP_PKEY\u003e,\n+    ) : XDH.PublicKey, Openssl3PublicKeyEncodable\u003cXDH.PublicKey.Format\u003e(key), SharedSecretGenerator\u003cXDH.PrivateKey\u003e {\n+        override fun outputType(format: XDH.PublicKey.Format): String = when (format) {\n+            XDH.PublicKey.Format.DER -\u003e \"DER\"\n+            XDH.PublicKey.Format.PEM -\u003e \"PEM\"\n+            XDH.PublicKey.Format.JWK,\n+            XDH.PublicKey.Format.RAW -\u003e error(\"$format format is not supported\")","id":2323041111,"in_reply_to_id":null,"line":69,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":69,"path":"cryptography-providers/openssl3/api/src/commonMain/kotlin/algorithms/Openssl3XDH.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"we should support RAW format (openSSL should support it)","diff_hunk":"@@ -0,0 +1,114 @@\n+/*\n+ * Copyright (c) 2025 Oleg Yukhnevich. Use of this source code is governed by the Apache 2.0 license.\n+ */\n+\n+package dev.whyoleg.cryptography.providers.openssl3.algorithms\n+\n+import dev.whyoleg.cryptography.algorithms.*\n+import dev.whyoleg.cryptography.materials.key.*\n+import dev.whyoleg.cryptography.operations.*\n+import dev.whyoleg.cryptography.providers.base.*\n+import dev.whyoleg.cryptography.providers.openssl3.internal.*\n+import dev.whyoleg.cryptography.providers.openssl3.internal.cinterop.*\n+import dev.whyoleg.cryptography.providers.openssl3.materials.*\n+import kotlinx.cinterop.*\n+import platform.posix.*\n+import kotlin.experimental.*\n+\n+internal object Openssl3XDH : XDH {\n+    private fun algorithmName(curve: XDH.Curve): String = when (curve) {\n+        XDH.Curve.X25519 -\u003e \"X25519\"\n+        XDH.Curve.X448   -\u003e \"X448\"\n+    }\n+\n+    override fun publicKeyDecoder(curve: XDH.Curve): KeyDecoder\u003cXDH.PublicKey.Format, XDH.PublicKey\u003e =\n+        object : Openssl3PublicKeyDecoder\u003cXDH.PublicKey.Format, XDH.PublicKey\u003e(algorithmName(curve)) {\n+            override fun inputType(format: XDH.PublicKey.Format): String = when (format) {\n+                XDH.PublicKey.Format.DER -\u003e \"DER\"\n+                XDH.PublicKey.Format.PEM -\u003e \"PEM\"\n+                XDH.PublicKey.Format.JWK,\n+                XDH.PublicKey.Format.RAW -\u003e error(\"$format format is not supported\")\n+            }\n+\n+            override fun wrapKey(key: CPointer\u003cEVP_PKEY\u003e): XDH.PublicKey = XdhPublicKey(key)\n+        }\n+\n+    override fun privateKeyDecoder(curve: XDH.Curve): KeyDecoder\u003cXDH.PrivateKey.Format, XDH.PrivateKey\u003e =\n+        object : Openssl3PrivateKeyDecoder\u003cXDH.PrivateKey.Format, XDH.PrivateKey\u003e(algorithmName(curve)) {\n+            override fun inputType(format: XDH.PrivateKey.Format): String = when (format) {\n+                XDH.PrivateKey.Format.DER -\u003e \"DER\"\n+                XDH.PrivateKey.Format.PEM -\u003e \"PEM\"\n+                XDH.PrivateKey.Format.JWK,\n+                XDH.PrivateKey.Format.RAW -\u003e error(\"$format format is not supported\")\n+            }\n+\n+            override fun wrapKey(key: CPointer\u003cEVP_PKEY\u003e): XDH.PrivateKey = XdhPrivateKey(key)\n+        }\n+\n+    override fun keyPairGenerator(curve: XDH.Curve): KeyGenerator\u003cXDH.KeyPair\u003e =\n+        object : Openssl3KeyPairGenerator\u003cXDH.KeyPair\u003e(algorithmName(curve)) {\n+            override fun MemScope.createParams(): CValuesRef\u003cOSSL_PARAM\u003e? = null\n+            override fun wrapKeyPair(keyPair: CPointer\u003cEVP_PKEY\u003e): XDH.KeyPair = XdhKeyPair(\n+                publicKey = XdhPublicKey(keyPair),\n+                privateKey = XdhPrivateKey(keyPair)\n+            )\n+        }\n+\n+    private class XdhKeyPair(\n+        override val publicKey: XDH.PublicKey,\n+        override val privateKey: XDH.PrivateKey,\n+    ) : XDH.KeyPair\n+\n+    private class XdhPublicKey(\n+        key: CPointer\u003cEVP_PKEY\u003e,\n+    ) : XDH.PublicKey, Openssl3PublicKeyEncodable\u003cXDH.PublicKey.Format\u003e(key), SharedSecretGenerator\u003cXDH.PrivateKey\u003e {\n+        override fun outputType(format: XDH.PublicKey.Format): String = when (format) {\n+            XDH.PublicKey.Format.DER -\u003e \"DER\"\n+            XDH.PublicKey.Format.PEM -\u003e \"PEM\"\n+            XDH.PublicKey.Format.JWK,\n+            XDH.PublicKey.Format.RAW -\u003e error(\"$format format is not supported\")\n+        }\n+\n+        override fun sharedSecretGenerator(): SharedSecretGenerator\u003cXDH.PrivateKey\u003e = this\n+        override fun generateSharedSecretToByteArrayBlocking(other: XDH.PrivateKey): ByteArray {\n+            check(other is XdhPrivateKey)\n+            return deriveSharedSecret(publicKey = key, privateKey = other.key)\n+        }\n+    }\n+\n+    private class XdhPrivateKey(\n+        key: CPointer\u003cEVP_PKEY\u003e,\n+    ) : XDH.PrivateKey, Openssl3PrivateKeyEncodable\u003cXDH.PrivateKey.Format\u003e(key), SharedSecretGenerator\u003cXDH.PublicKey\u003e {\n+        override fun outputType(format: XDH.PrivateKey.Format): String = when (format) {\n+            XDH.PrivateKey.Format.DER -\u003e \"DER\"\n+            XDH.PrivateKey.Format.PEM -\u003e \"PEM\"\n+            XDH.PrivateKey.Format.JWK,\n+            XDH.PrivateKey.Format.RAW -\u003e error(\"$format format is not supported\")","id":2323041303,"in_reply_to_id":null,"line":86,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":86,"path":"cryptography-providers/openssl3/api/src/commonMain/kotlin/algorithms/Openssl3XDH.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"what is the reason for reimplementing this from scratch? It looks like we only need to make `hashAlgorithm` nullable in `Openssl3DigestSignatureVerifier` and `Openssl3DigestSignatureGenerator` no?","diff_hunk":"@@ -0,0 +1,265 @@\n+/*\n+ * Copyright (c) 2025 Oleg Yukhnevich. Use of this source code is governed by the Apache 2.0 license.\n+ */\n+\n+package dev.whyoleg.cryptography.providers.openssl3.algorithms\n+\n+import dev.whyoleg.cryptography.algorithms.*\n+import dev.whyoleg.cryptography.materials.key.*\n+import dev.whyoleg.cryptography.operations.*\n+import dev.whyoleg.cryptography.providers.base.*\n+import dev.whyoleg.cryptography.providers.openssl3.internal.*\n+import dev.whyoleg.cryptography.providers.openssl3.internal.cinterop.*\n+import dev.whyoleg.cryptography.providers.openssl3.materials.*\n+import kotlinx.cinterop.*\n+import platform.posix.*\n+import kotlin.experimental.*\n+\n+internal object Openssl3EdDSA : EdDSA {\n+    private fun algorithmName(curve: EdDSA.Curve): String = when (curve) {\n+        EdDSA.Curve.Ed25519 -\u003e \"ED25519\"\n+        EdDSA.Curve.Ed448   -\u003e \"ED448\"\n+    }\n+\n+    override fun publicKeyDecoder(curve: EdDSA.Curve): KeyDecoder\u003cEdDSA.PublicKey.Format, EdDSA.PublicKey\u003e =\n+        object : Openssl3PublicKeyDecoder\u003cEdDSA.PublicKey.Format, EdDSA.PublicKey\u003e(algorithmName(curve)) {\n+            override fun inputType(format: EdDSA.PublicKey.Format): String = when (format) {\n+                EdDSA.PublicKey.Format.DER -\u003e \"DER\"\n+                EdDSA.PublicKey.Format.PEM -\u003e \"PEM\"\n+                EdDSA.PublicKey.Format.JWK,\n+                EdDSA.PublicKey.Format.RAW -\u003e error(\"$format format is not supported\")\n+            }\n+\n+            override fun wrapKey(key: CPointer\u003cEVP_PKEY\u003e): EdDSA.PublicKey = EdDsaPublicKey(key)\n+        }\n+\n+    override fun privateKeyDecoder(curve: EdDSA.Curve): KeyDecoder\u003cEdDSA.PrivateKey.Format, EdDSA.PrivateKey\u003e =\n+        object : Openssl3PrivateKeyDecoder\u003cEdDSA.PrivateKey.Format, EdDSA.PrivateKey\u003e(algorithmName(curve)) {\n+            override fun inputType(format: EdDSA.PrivateKey.Format): String = when (format) {\n+                EdDSA.PrivateKey.Format.DER -\u003e \"DER\"\n+                EdDSA.PrivateKey.Format.PEM -\u003e \"PEM\"\n+                EdDSA.PrivateKey.Format.JWK,\n+                EdDSA.PrivateKey.Format.RAW -\u003e error(\"$format format is not supported\")\n+            }\n+\n+            override fun wrapKey(key: CPointer\u003cEVP_PKEY\u003e): EdDSA.PrivateKey = EdDsaPrivateKey(key)\n+        }\n+\n+    override fun keyPairGenerator(curve: EdDSA.Curve): KeyGenerator\u003cEdDSA.KeyPair\u003e =\n+        object : Openssl3KeyPairGenerator\u003cEdDSA.KeyPair\u003e(algorithmName(curve)) {\n+            override fun MemScope.createParams(): CValuesRef\u003cOSSL_PARAM\u003e? = null\n+            override fun wrapKeyPair(keyPair: CPointer\u003cEVP_PKEY\u003e): EdDSA.KeyPair = EdDsaKeyPair(\n+                publicKey = EdDsaPublicKey(keyPair),\n+                privateKey = EdDsaPrivateKey(keyPair)\n+            )\n+        }\n+\n+    private class EdDsaKeyPair(\n+        override val publicKey: EdDSA.PublicKey,\n+        override val privateKey: EdDSA.PrivateKey,\n+    ) : EdDSA.KeyPair\n+\n+    private class EdDsaPublicKey(\n+        key: CPointer\u003cEVP_PKEY\u003e,\n+    ) : EdDSA.PublicKey, Openssl3PublicKeyEncodable\u003cEdDSA.PublicKey.Format\u003e(key) {\n+        override fun outputType(format: EdDSA.PublicKey.Format): String = when (format) {\n+            EdDSA.PublicKey.Format.DER -\u003e \"DER\"\n+            EdDSA.PublicKey.Format.PEM -\u003e \"PEM\"\n+            EdDSA.PublicKey.Format.JWK,\n+            EdDSA.PublicKey.Format.RAW -\u003e error(\"$format format is not supported\")\n+        }\n+\n+        override fun signatureVerifier(): SignatureVerifier = EdDsaSignatureVerifier(key)\n+    }\n+\n+    private class EdDsaPrivateKey(\n+        key: CPointer\u003cEVP_PKEY\u003e,\n+    ) : EdDSA.PrivateKey, Openssl3PrivateKeyEncodable\u003cEdDSA.PrivateKey.Format\u003e(key) {\n+        override fun outputType(format: EdDSA.PrivateKey.Format): String = when (format) {\n+            EdDSA.PrivateKey.Format.DER -\u003e \"DER\"\n+            EdDSA.PrivateKey.Format.PEM -\u003e \"PEM\"\n+            EdDSA.PrivateKey.Format.JWK,\n+            EdDSA.PrivateKey.Format.RAW -\u003e error(\"$format format is not supported\")\n+        }\n+\n+        override fun signatureGenerator(): SignatureGenerator = EdDsaSignatureGenerator(key)\n+    }\n+}\n+\n+@OptIn(ExperimentalNativeApi::class, UnsafeNumber::class)\n+private class EdDsaSignatureGenerator(","id":2323048552,"in_reply_to_id":null,"line":90,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":90,"path":"cryptography-providers/openssl3/api/src/commonMain/kotlin/algorithms/Openssl3EdDSA.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"why can't we support it? (same in other places in JDK provider)","diff_hunk":"@@ -0,0 +1,89 @@\n+package dev.whyoleg.cryptography.providers.jdk.algorithms\n+\n+import dev.whyoleg.cryptography.algorithms.*\n+import dev.whyoleg.cryptography.materials.key.*\n+import dev.whyoleg.cryptography.operations.*\n+import dev.whyoleg.cryptography.providers.jdk.*\n+import dev.whyoleg.cryptography.providers.jdk.materials.*\n+import dev.whyoleg.cryptography.providers.base.materials.*\n+import dev.whyoleg.cryptography.providers.jdk.operations.*\n+import dev.whyoleg.cryptography.serialization.pem.*\n+\n+internal class JdkEdDSA(private val state: JdkCryptographyState) : EdDSA {\n+    private fun curveName(curve: EdDSA.Curve): String = when (curve) {\n+        EdDSA.Curve.Ed25519 -\u003e \"Ed25519\"\n+        EdDSA.Curve.Ed448   -\u003e \"Ed448\"\n+    }\n+\n+    override fun publicKeyDecoder(curve: EdDSA.Curve): KeyDecoder\u003cEdDSA.PublicKey.Format, EdDSA.PublicKey\u003e =\n+        object : JdkPublicKeyDecoder\u003cEdDSA.PublicKey.Format, EdDSA.PublicKey\u003e(state, curveName(curve)) {\n+            override fun JPublicKey.convert(): EdDSA.PublicKey = EdDsaPublicKey(state, this)\n+\n+            override fun decodeFromByteArrayBlocking(format: EdDSA.PublicKey.Format, bytes: ByteArray): EdDSA.PublicKey = when (format) {\n+                EdDSA.PublicKey.Format.JWK -\u003e error(\"JWK is not supported\")\n+                EdDSA.PublicKey.Format.RAW -\u003e TODO(\"RAW encoding is not supported yet\")","id":2323050460,"in_reply_to_id":null,"line":24,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":24,"path":"cryptography-providers/jdk/src/jvmMain/kotlin/algorithms/JdkEdDSA.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"OIDs should be extracted and added into `asn1-modules` with correct names (same for xdh)","diff_hunk":"@@ -0,0 +1,182 @@\n+/*\n+ * Copyright (c) 2025 Oleg Yukhnevich. Use of this source code is governed by the Apache 2.0 license.\n+ */\n+\n+package dev.whyoleg.cryptography.providers.cryptokit.algorithms\n+\n+import dev.whyoleg.cryptography.algorithms.*\n+import dev.whyoleg.cryptography.materials.key.*\n+import dev.whyoleg.cryptography.operations.*\n+import dev.whyoleg.cryptography.providers.cryptokit.internal.*\n+import dev.whyoleg.cryptography.providers.cryptokit.internal.swiftinterop.*\n+import dev.whyoleg.cryptography.providers.base.*\n+import dev.whyoleg.cryptography.providers.base.materials.*\n+import dev.whyoleg.cryptography.serialization.asn1.*\n+import dev.whyoleg.cryptography.serialization.asn1.modules.*\n+import dev.whyoleg.cryptography.serialization.pem.*\n+import kotlinx.cinterop.*\n+import platform.Foundation.*\n+\n+internal object CryptoKitEdDSA : EdDSA {\n+    override fun publicKeyDecoder(curve: EdDSA.Curve): KeyDecoder\u003cEdDSA.PublicKey.Format, EdDSA.PublicKey\u003e {\n+        check(curve == EdDSA.Curve.Ed25519) { \"CryptoKit supports Ed25519 only\" }\n+        return object : KeyDecoder\u003cEdDSA.PublicKey.Format, EdDSA.PublicKey\u003e {\n+            override fun decodeFromByteArrayBlocking(format: EdDSA.PublicKey.Format, bytes: ByteArray): EdDSA.PublicKey = when (format) {\n+                EdDSA.PublicKey.Format.RAW -\u003e EdPublic(\n+                    swiftTry\u003cSwiftEdDsaPublicKey\u003e { error -\u003e bytes.useNSData { SwiftEdDsaPublicKey.decodeRawWithRawRepresentation(it, error) } }\n+                )\n+                EdDSA.PublicKey.Format.DER -\u003e {\n+                    val raw = unwrapSubjectPublicKeyInfo(ObjectIdentifier(\"1.3.101.112\"), bytes)","id":2323056088,"in_reply_to_id":null,"line":29,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":29,"path":"cryptography-providers/cryptokit/src/commonMain/kotlin/algorithms/CryptoKitEdDSA.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"it would be nice to add this into `cryptokit.md`: that only this curve is supported (same for xdh) ","diff_hunk":"@@ -0,0 +1,182 @@\n+/*\n+ * Copyright (c) 2025 Oleg Yukhnevich. Use of this source code is governed by the Apache 2.0 license.\n+ */\n+\n+package dev.whyoleg.cryptography.providers.cryptokit.algorithms\n+\n+import dev.whyoleg.cryptography.algorithms.*\n+import dev.whyoleg.cryptography.materials.key.*\n+import dev.whyoleg.cryptography.operations.*\n+import dev.whyoleg.cryptography.providers.cryptokit.internal.*\n+import dev.whyoleg.cryptography.providers.cryptokit.internal.swiftinterop.*\n+import dev.whyoleg.cryptography.providers.base.*\n+import dev.whyoleg.cryptography.providers.base.materials.*\n+import dev.whyoleg.cryptography.serialization.asn1.*\n+import dev.whyoleg.cryptography.serialization.asn1.modules.*\n+import dev.whyoleg.cryptography.serialization.pem.*\n+import kotlinx.cinterop.*\n+import platform.Foundation.*\n+\n+internal object CryptoKitEdDSA : EdDSA {\n+    override fun publicKeyDecoder(curve: EdDSA.Curve): KeyDecoder\u003cEdDSA.PublicKey.Format, EdDSA.PublicKey\u003e {\n+        check(curve == EdDSA.Curve.Ed25519) { \"CryptoKit supports Ed25519 only\" }","id":2323060834,"in_reply_to_id":null,"line":22,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":22,"path":"cryptography-providers/cryptokit/src/commonMain/kotlin/algorithms/CryptoKitEdDSA.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"should be removed","diff_hunk":"@@ -0,0 +1,130 @@\n+/*\n+ * Copyright (c) 2025 Oleg Yukhnevich. Use of this source code is governed by the Apache 2.0 license.\n+ */\n+\n+package dev.whyoleg.cryptography.providers.cryptokit.algorithms\n+\n+import dev.whyoleg.cryptography.algorithms.*\n+import dev.whyoleg.cryptography.materials.key.*\n+import dev.whyoleg.cryptography.operations.*\n+import dev.whyoleg.cryptography.providers.cryptokit.internal.*\n+import dev.whyoleg.cryptography.providers.cryptokit.internal.swiftinterop.*\n+import dev.whyoleg.cryptography.providers.base.*\n+import dev.whyoleg.cryptography.providers.base.materials.*\n+import dev.whyoleg.cryptography.serialization.asn1.*\n+import dev.whyoleg.cryptography.serialization.asn1.modules.*\n+import dev.whyoleg.cryptography.serialization.pem.*\n+import kotlinx.cinterop.*\n+import platform.Foundation.*\n+\n+internal object CryptoKitXDH : XDH {\n+    override fun publicKeyDecoder(curve: XDH.Curve): KeyDecoder\u003cXDH.PublicKey.Format, XDH.PublicKey\u003e {\n+        check(curve == XDH.Curve.X25519) { \"CryptoKit supports X25519 only\" }\n+        return object : KeyDecoder\u003cXDH.PublicKey.Format, XDH.PublicKey\u003e {\n+            override fun decodeFromByteArrayBlocking(format: XDH.PublicKey.Format, bytes: ByteArray): XDH.PublicKey = when (format) {\n+                XDH.PublicKey.Format.RAW -\u003e XPublic(\n+                    swiftTry\u003cSwiftXdhPublicKey\u003e { error -\u003e bytes.useNSData { SwiftXdhPublicKey.decodeRawWithRawRepresentation(it, error) } }\n+                )\n+                XDH.PublicKey.Format.DER -\u003e {\n+                    val raw = unwrapSubjectPublicKeyInfo(ObjectIdentifier(\"1.3.101.110\"), bytes)\n+                    XPublic(swiftTry { error -\u003e raw.useNSData { SwiftXdhPublicKey.decodeRawWithRawRepresentation(it, error) } })\n+                }\n+                XDH.PublicKey.Format.PEM -\u003e {\n+                    val der = unwrapPem(PemLabel.PublicKey, bytes)\n+                    val raw = unwrapSubjectPublicKeyInfo(ObjectIdentifier(\"1.3.101.110\"), der)\n+                    XPublic(swiftTry { error -\u003e raw.useNSData { SwiftXdhPublicKey.decodeRawWithRawRepresentation(it, error) } })\n+                }\n+                else -\u003e error(\"$format is not supported by CryptoKit XDH\")\n+            }\n+        }\n+    }\n+\n+    override fun privateKeyDecoder(curve: XDH.Curve): KeyDecoder\u003cXDH.PrivateKey.Format, XDH.PrivateKey\u003e {\n+        check(curve == XDH.Curve.X25519) { \"CryptoKit supports X25519 only\" }\n+        return object : KeyDecoder\u003cXDH.PrivateKey.Format, XDH.PrivateKey\u003e {\n+            override fun decodeFromByteArrayBlocking(format: XDH.PrivateKey.Format, bytes: ByteArray): XDH.PrivateKey = when (format) {\n+                XDH.PrivateKey.Format.RAW -\u003e XPrivate(\n+                    swiftTry\u003cSwiftXdhPrivateKey\u003e { error -\u003e bytes.useNSData { SwiftXdhPrivateKey.decodeRawWithRawRepresentation(it, error) } }\n+                )\n+                XDH.PrivateKey.Format.DER -\u003e {\n+                    val raw = unwrapPrivateKeyInfo(ObjectIdentifier(\"1.3.101.110\"), bytes)\n+                    XPrivate(swiftTry { error -\u003e raw.useNSData { SwiftXdhPrivateKey.decodeRawWithRawRepresentation(it, error) } })\n+                }\n+                XDH.PrivateKey.Format.PEM -\u003e {\n+                    val der = unwrapPem(PemLabel.PrivateKey, bytes)\n+                    val raw = unwrapPrivateKeyInfo(ObjectIdentifier(\"1.3.101.110\"), der)\n+                    XPrivate(swiftTry { error -\u003e raw.useNSData { SwiftXdhPrivateKey.decodeRawWithRawRepresentation(it, error) } })\n+                }\n+                else -\u003e error(\"$format is not supported by CryptoKit XDH\")\n+            }\n+        }\n+    }\n+\n+    override fun keyPairGenerator(curve: XDH.Curve): KeyGenerator\u003cXDH.KeyPair\u003e {\n+        check(curve == XDH.Curve.X25519) { \"CryptoKit supports X25519 only\" }\n+        return object : KeyGenerator\u003cXDH.KeyPair\u003e {\n+            override fun generateKeyBlocking(): XDH.KeyPair {\n+                val p = SwiftXdhPrivateKey.generate()\n+                return XKeyPair(XPublic(p.publicKey()), XPrivate(p))\n+            }\n+        }\n+    }\n+\n+    private class XKeyPair(\n+        override val publicKey: XDH.PublicKey,\n+        override val privateKey: XDH.PrivateKey,\n+    ) : XDH.KeyPair\n+\n+    private class XPublic(\n+        val key: SwiftXdhPublicKey,\n+    ) : XDH.PublicKey, SharedSecretGenerator\u003cXDH.PrivateKey\u003e {\n+        override fun encodeToByteArrayBlocking(format: XDH.PublicKey.Format): ByteArray = when (format) {\n+            XDH.PublicKey.Format.RAW -\u003e key.rawRepresentation().toByteArray()\n+            XDH.PublicKey.Format.DER -\u003e wrapSubjectPublicKeyInfo(\n+                UnknownKeyAlgorithmIdentifier(ObjectIdentifier(\"1.3.101.110\")),\n+                key.rawRepresentation().toByteArray()\n+            )\n+            XDH.PublicKey.Format.PEM -\u003e wrapPem(\n+                PemLabel.PublicKey,\n+                wrapSubjectPublicKeyInfo(\n+                    UnknownKeyAlgorithmIdentifier(ObjectIdentifier(\"1.3.101.110\")),\n+                    key.rawRepresentation().toByteArray()\n+                )\n+            )\n+            else -\u003e error(\"$format is not supported by CryptoKit XDH\")\n+        }\n+        override fun sharedSecretGenerator(): SharedSecretGenerator\u003cXDH.PrivateKey\u003e = this\n+        override fun generateSharedSecretToByteArrayBlocking(other: XDH.PrivateKey): ByteArray {\n+            require(other is XPrivate)\n+            return swiftTry { error -\u003e other.key.deriveSecretWith(key, error) }.toByteArray()\n+        }\n+    }\n+\n+    private class XPrivate(\n+        val key: SwiftXdhPrivateKey,\n+    ) : XDH.PrivateKey, SharedSecretGenerator\u003cXDH.PublicKey\u003e {\n+        override fun encodeToByteArrayBlocking(format: XDH.PrivateKey.Format): ByteArray = when (format) {\n+            XDH.PrivateKey.Format.RAW -\u003e key.rawRepresentation().toByteArray()\n+            XDH.PrivateKey.Format.DER -\u003e wrapPrivateKeyInfo(\n+                0,\n+                UnknownKeyAlgorithmIdentifier(ObjectIdentifier(\"1.3.101.110\")),\n+                key.rawRepresentation().toByteArray()\n+            )\n+            XDH.PrivateKey.Format.PEM -\u003e wrapPem(\n+                PemLabel.PrivateKey,\n+                wrapPrivateKeyInfo(\n+                    0,\n+                    UnknownKeyAlgorithmIdentifier(ObjectIdentifier(\"1.3.101.110\")),\n+                    key.rawRepresentation().toByteArray()\n+                )\n+            )\n+            else -\u003e error(\"$format is not supported by CryptoKit XDH\")\n+        }\n+        override fun sharedSecretGenerator(): SharedSecretGenerator\u003cXDH.PublicKey\u003e = this\n+        override fun generateSharedSecretToByteArrayBlocking(other: XDH.PublicKey): ByteArray {\n+            require(other is XPublic)\n+            return swiftTry { error -\u003e key.deriveSecretWith(other.key, error) }.toByteArray()\n+    }\n+    }\n+}\n+// NSData helpers provided by cryptography-providers-base","id":2323064442,"in_reply_to_id":null,"line":130,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":130,"path":"cryptography-providers/cryptokit/src/commonMain/kotlin/algorithms/CryptoKitXDH.kt","side":"RIGHT","start_line":null}
{"author":"whyoleg","body":"The implementation looks similar to `SecSignFunction` from apple provider. It would be nice to extract the base implementation into `AccumulatingSignFunction` and place it into `provider-base`, so that it will be shared in the same way `AccumulatingCipherFunction` is shared and used in this cryptokit provider\nSame for `verify`","diff_hunk":"@@ -0,0 +1,182 @@\n+/*\n+ * Copyright (c) 2025 Oleg Yukhnevich. Use of this source code is governed by the Apache 2.0 license.\n+ */\n+\n+package dev.whyoleg.cryptography.providers.cryptokit.algorithms\n+\n+import dev.whyoleg.cryptography.algorithms.*\n+import dev.whyoleg.cryptography.materials.key.*\n+import dev.whyoleg.cryptography.operations.*\n+import dev.whyoleg.cryptography.providers.cryptokit.internal.*\n+import dev.whyoleg.cryptography.providers.cryptokit.internal.swiftinterop.*\n+import dev.whyoleg.cryptography.providers.base.*\n+import dev.whyoleg.cryptography.providers.base.materials.*\n+import dev.whyoleg.cryptography.serialization.asn1.*\n+import dev.whyoleg.cryptography.serialization.asn1.modules.*\n+import dev.whyoleg.cryptography.serialization.pem.*\n+import kotlinx.cinterop.*\n+import platform.Foundation.*\n+\n+internal object CryptoKitEdDSA : EdDSA {\n+    override fun publicKeyDecoder(curve: EdDSA.Curve): KeyDecoder\u003cEdDSA.PublicKey.Format, EdDSA.PublicKey\u003e {\n+        check(curve == EdDSA.Curve.Ed25519) { \"CryptoKit supports Ed25519 only\" }\n+        return object : KeyDecoder\u003cEdDSA.PublicKey.Format, EdDSA.PublicKey\u003e {\n+            override fun decodeFromByteArrayBlocking(format: EdDSA.PublicKey.Format, bytes: ByteArray): EdDSA.PublicKey = when (format) {\n+                EdDSA.PublicKey.Format.RAW -\u003e EdPublic(\n+                    swiftTry\u003cSwiftEdDsaPublicKey\u003e { error -\u003e bytes.useNSData { SwiftEdDsaPublicKey.decodeRawWithRawRepresentation(it, error) } }\n+                )\n+                EdDSA.PublicKey.Format.DER -\u003e {\n+                    val raw = unwrapSubjectPublicKeyInfo(ObjectIdentifier(\"1.3.101.112\"), bytes)\n+                    EdPublic(swiftTry { error -\u003e raw.useNSData { SwiftEdDsaPublicKey.decodeRawWithRawRepresentation(it, error) } })\n+                }\n+                EdDSA.PublicKey.Format.PEM -\u003e {\n+                    val der = unwrapPem(PemLabel.PublicKey, bytes)\n+                    val raw = unwrapSubjectPublicKeyInfo(ObjectIdentifier(\"1.3.101.112\"), der)\n+                    EdPublic(swiftTry { error -\u003e raw.useNSData { SwiftEdDsaPublicKey.decodeRawWithRawRepresentation(it, error) } })\n+                }\n+                else -\u003e error(\"$format is not supported by CryptoKit EdDSA\")\n+            }\n+        }\n+    }\n+\n+    override fun privateKeyDecoder(curve: EdDSA.Curve): KeyDecoder\u003cEdDSA.PrivateKey.Format, EdDSA.PrivateKey\u003e {\n+        check(curve == EdDSA.Curve.Ed25519) { \"CryptoKit supports Ed25519 only\" }\n+        return object : KeyDecoder\u003cEdDSA.PrivateKey.Format, EdDSA.PrivateKey\u003e {\n+            override fun decodeFromByteArrayBlocking(format: EdDSA.PrivateKey.Format, bytes: ByteArray): EdDSA.PrivateKey = when (format) {\n+                EdDSA.PrivateKey.Format.RAW -\u003e EdPrivate(\n+                    swiftTry\u003cSwiftEdDsaPrivateKey\u003e { error -\u003e bytes.useNSData { SwiftEdDsaPrivateKey.decodeRawWithRawRepresentation(it, error) } }\n+                )\n+                EdDSA.PrivateKey.Format.DER -\u003e {\n+                    val raw = unwrapPrivateKeyInfo(ObjectIdentifier(\"1.3.101.112\"), bytes)\n+                    EdPrivate(swiftTry { error -\u003e raw.useNSData { SwiftEdDsaPrivateKey.decodeRawWithRawRepresentation(it, error) } })\n+                }\n+                EdDSA.PrivateKey.Format.PEM -\u003e {\n+                    val der = unwrapPem(PemLabel.PrivateKey, bytes)\n+                    val raw = unwrapPrivateKeyInfo(ObjectIdentifier(\"1.3.101.112\"), der)\n+                    EdPrivate(swiftTry { error -\u003e raw.useNSData { SwiftEdDsaPrivateKey.decodeRawWithRawRepresentation(it, error) } })\n+                }\n+                else -\u003e error(\"$format is not supported by CryptoKit EdDSA\")\n+            }\n+        }\n+    }\n+\n+    override fun keyPairGenerator(curve: EdDSA.Curve): KeyGenerator\u003cEdDSA.KeyPair\u003e {\n+        check(curve == EdDSA.Curve.Ed25519) { \"CryptoKit supports Ed25519 only\" }\n+        return object : KeyGenerator\u003cEdDSA.KeyPair\u003e {\n+            override fun generateKeyBlocking(): EdDSA.KeyPair {\n+                val p = SwiftEdDsaPrivateKey.generate()\n+                return EdKeyPair(EdPublic(p.publicKey()), EdPrivate(p))\n+            }\n+        }\n+    }\n+\n+    private class EdKeyPair(\n+        override val publicKey: EdDSA.PublicKey,\n+        override val privateKey: EdDSA.PrivateKey,\n+    ) : EdDSA.KeyPair\n+\n+    private class EdPublic(\n+        val key: SwiftEdDsaPublicKey,\n+    ) : EdDSA.PublicKey {\n+        override fun encodeToByteArrayBlocking(format: EdDSA.PublicKey.Format): ByteArray = when (format) {\n+            EdDSA.PublicKey.Format.RAW -\u003e key.rawRepresentation().toByteArray()\n+            EdDSA.PublicKey.Format.DER -\u003e wrapSubjectPublicKeyInfo(\n+                UnknownKeyAlgorithmIdentifier(ObjectIdentifier(\"1.3.101.112\")),\n+                key.rawRepresentation().toByteArray()\n+            )\n+            EdDSA.PublicKey.Format.PEM -\u003e wrapPem(\n+                PemLabel.PublicKey,\n+                wrapSubjectPublicKeyInfo(\n+                    UnknownKeyAlgorithmIdentifier(ObjectIdentifier(\"1.3.101.112\")),\n+                    key.rawRepresentation().toByteArray()\n+                )\n+            )\n+            else -\u003e error(\"$format is not supported by CryptoKit EdDSA\")\n+        }\n+\n+        override fun signatureVerifier(): SignatureVerifier = object : SignatureVerifier {\n+            override fun createVerifyFunction(): VerifyFunction = EdVerifyFunction(key)\n+        }\n+    }\n+\n+    private class EdPrivate(\n+        val key: SwiftEdDsaPrivateKey,\n+    ) : EdDSA.PrivateKey {\n+        override fun encodeToByteArrayBlocking(format: EdDSA.PrivateKey.Format): ByteArray = when (format) {\n+            EdDSA.PrivateKey.Format.RAW -\u003e key.rawRepresentation().toByteArray()\n+            EdDSA.PrivateKey.Format.DER -\u003e wrapPrivateKeyInfo(\n+                0,\n+                UnknownKeyAlgorithmIdentifier(ObjectIdentifier(\"1.3.101.112\")),\n+                key.rawRepresentation().toByteArray()\n+            )\n+            EdDSA.PrivateKey.Format.PEM -\u003e wrapPem(\n+                PemLabel.PrivateKey,\n+                wrapPrivateKeyInfo(\n+                    0,\n+                    UnknownKeyAlgorithmIdentifier(ObjectIdentifier(\"1.3.101.112\")),\n+                    key.rawRepresentation().toByteArray()\n+                )\n+            )\n+            else -\u003e error(\"$format is not supported by CryptoKit EdDSA\")\n+        }\n+\n+        override fun signatureGenerator(): SignatureGenerator = object : SignatureGenerator {\n+            override fun createSignFunction(): SignFunction = EdSignFunction(key)\n+            override fun generateSignatureBlocking(data: ByteArray): ByteArray =\n+                swiftTry { error -\u003e data.useNSData { key.signWithMessage(it, error) } }.toByteArray()\n+        }\n+    }\n+}\n+\n+private class EdSignFunction(","id":2323074323,"in_reply_to_id":null,"line":131,"original_commit_id":"c8488c9a2b9a24362bf1b5b7018a29e8e2286937","original_line":131,"path":"cryptography-providers/cryptokit/src/commonMain/kotlin/algorithms/CryptoKitEdDSA.kt","side":"RIGHT","start_line":null}
